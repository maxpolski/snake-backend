{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["CANVAS_HEIGHT","CANVAS_WIDTH","SNAKESTARTING_POSITION","getRandomInt","max","Math","floor","random","getRandomSquareCoords","checkValidity","newCoords","App","canvasRef","useRef","renderIntervalRef","gameTicksIntervalRef","useState","userName","setUserName","leaderBoard","setLeaderBoard","isGameOver","setIsGameOver","showSaveResultForm","setShowSaveResultForm","isChangeDirectionBlocked","setIsChangeDirectionBlocked","snakeSquaresData","setSnakeSquaresData","prevPositions","setPrevPositions","direction","setDirection","feedPostion","setFeedPosition","startGame","useCallback","position","coords","getLeaderBoard","a","fetch","process","resp","json","data","useEffect","draw","current","canvasContext","getContext","clearRect","canvas","width","height","fillStyle","fillRect","i","length","SNAKE_BODY_SQUARE_SIZE","handleGameOver","checkSnakeSelfCollision","headPosition","find","sd","gameTick","pos","prevLastPosition","newSquaresData","map","index","rest","newLeftPos","newRightPos","newUpPos","newDownPos","newData","np","setInterval","clearTimeout","document","onkeydown","e","key","preventDefault","currentRecord","useMemo","sort","b","record","currentResult","handleSaveResult","method","headers","body","JSON","stringify","name","style","display","justifyContent","alignItems","flexDirection","className","border","ref","backgroundColor","padding","onClick","role","href","cursor","color","htmlFor","id","value","onChange","target","maxHeight","overflow","lb","user","toString","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","dotenv","config","ReactDOM","render","StrictMode","getElementById"],"mappings":"kQAeMA,G,MAAgB,KAChBC,EAAe,IAEfC,EAA2C,CAC/CD,IACAD,KAGF,SAASG,EAAaC,GAGpB,OAFYC,KAAKC,MAAMD,KAAKE,SAAWF,KAAKC,MAAMF,IAKpD,SAASI,EACPC,GAOA,IALA,IAAIC,EAA8B,CAChCP,EAAaF,KACbE,EAAaH,OAGPS,EAAcC,IACpBA,EAAY,CACVP,EAAaF,KACbE,EAAaH,MAIjB,OAAOU,EAsZMC,MAnZf,WACE,IAAMC,EAAYC,iBAA0B,MACtCC,EAAoBD,iBAA8C,MAClEE,EAAuBF,iBAC3B,MAJW,EAMmBG,mBAAS,IAN5B,mBAMNC,EANM,KAMIC,EANJ,OAOyBF,mBAEpC,IATW,mBAONG,EAPM,KAOOC,EAPP,OAUuBJ,oBAAS,GAVhC,mBAUNK,EAVM,KAUMC,EAVN,OAWuCN,oBAAS,GAXhD,mBAWNO,EAXM,KAWcC,EAXd,OAYmDR,oBAC9D,GAbW,mBAYNS,EAZM,KAYoBC,EAZpB,OAemCV,mBAE9C,IAjBW,mBAeNW,EAfM,KAeYC,EAfZ,OAkB6BZ,mBACxC,IAnBW,mBAkBNa,EAlBM,KAkBSC,EAlBT,OAqBqBd,mBAAoB,QArBzC,mBAqBNe,EArBM,KAqBKC,EArBL,OAsB0BhB,mBAA2B,CAAC,EAAG,IAtBzD,mBAsBNiB,EAtBM,KAsBOC,EAtBP,KAwBPC,EAAYC,uBAAY,WAC5BR,EAAoB,CAClB,CAAES,SAAUnC,EAAwB6B,UAAW,UAEjDD,EAAiB,IACjBR,GAAc,GACdY,EACE1B,GAAsB,SAAC8B,GACrB,OACEA,EAAO,GArEc,IAqEkB,IACtCA,EAAO,GAAKpC,EAAuB,IAClCoC,EAAO,GAAKpC,EAAuB,KACrCoC,EAAO,GAxEc,IAwEkB,IACtCA,EAAO,GAAKpC,EAAuB,IAClCoC,EAAO,GAAKpC,EAAuB,UAI1C,CAAC0B,EAAqBE,EAAkBR,IAErCiB,EAAiBH,sBAAW,sBAAC,8BAAAI,EAAA,sEACdC,MAAM,GAAD,OAAIC,oCAAJ,aADS,cAC3BC,EAD2B,gBAOtBA,EAAKC,OAPiB,cAG3BC,EAH2B,OASjCzB,EAAeyB,GATkB,kBAU1BA,GAV0B,2CAWhC,CAACzB,IAEJ0B,qBAAU,WACRX,IACAI,MACC,IAEH,IAAMQ,GAAOX,uBAAY,WACvB,GAAIxB,EAAUoC,QAAS,CACrB,IAAMC,EAAgBrC,EAAUoC,QAAQE,WAAW,MACnD,IAAK7B,EAAY,CACf4B,EAAcE,UACZ,EACA,EACAF,EAAcG,OAAOC,MACrBJ,EAAcG,OAAOE,QAGvBL,EAAcM,UAAY,QAC1BN,EAAcO,SAAd,MAAAP,EAAa,YACRhB,GADQ,QA9GU,OAoHvB,IAAK,IAAIwB,EAAI,EAAGA,EAAI9B,EAAiB+B,OAAQD,IAC3CR,EAAcM,UAAY,OAC1BN,EAAcO,SAAd,MAAAP,EAAa,YACRtB,EAAiB8B,GAAGpB,UADZ,QAtHQ,OA4HrBY,EAAcM,UAAY,QAC1BN,EAAcO,SACZ7B,EAAiB8B,GAAGpB,SAAS,GAAK,EAClCV,EAAiB8B,GAAGpB,SAAS,GAAK,EAClCsB,EACAA,OAKP,CAAChC,EAAkBM,EAAaZ,IAE7BuC,GAAiBxB,uBAAY,WACjCG,IACAf,GAAsB,KACrB,CAACe,IAEJO,qBAAU,WACJzB,GACFuC,OAED,CAACvC,EAAYuC,KAEhB,IAAMC,GAA0BzB,uBAAY,WAAO,IAAD,cACFT,GAA3BmC,EAD6B,KACvCzB,SAET,QAHgD,WAGlC0B,MACZ,SAACC,GAAD,OACEA,EAAG3B,SAAS,KAAOyB,EAAa,IAAME,EAAG3B,SAAS,KAAOyB,EAAa,QAEzE,CAACnC,IAEEsC,GAAW7B,uBAAY,WAG3B,GAFwByB,KAGtBvC,GAAc,OADhB,CAKA,IAA4B4C,EAGtBC,EAAmBxC,EAAiBA,EAAiB+B,OAAS,GAE9DU,EAAiBzC,EAAiB0C,KAGrC,WAA6BC,GAAW,IAA3BJ,EAA0B,EAApC7B,SAAkBkC,EAAkB,4BACxC,GAAc,IAAVD,EACF,OAAQvC,GACN,IAAK,OACH,IAAMyC,EAAaN,EAAI,GAhLJ,EAiLnB,OAAO,2BACFK,GADL,IAEElC,SAAU,CACRmC,EAAa,EACTvE,IACAuE,EACJN,EAAI,MAGV,IAAK,QACH,IAAMO,EAAcP,EAAI,GA3LL,EA4LnB,OAAO,2BACFK,GADL,IAEElC,SAAU,CAACoC,GAAexE,EAAe,EAAIwE,EAAaP,EAAI,MAElE,IAAK,KACH,IAAMQ,EAAWR,EAAI,GAjMF,EAkMnB,OAAO,2BACFK,GADL,IAEElC,SAAU,CACR6B,EAAI,GACJQ,EAAW,EACP1E,IACA0E,KAGV,IAAK,OACH,IAAMC,EAAaT,EAAI,GA5MJ,EA6MnB,OAAO,2BACFK,GADL,IAEElC,SAAU,CAAC6B,EAAI,GAAIS,GAAc3E,EAAgB,EAAI2E,KAEzD,QACE,OAAO,2BAAKJ,GAAZ,IAAkBlC,SAAU6B,IAIlC,OAAO,2BAAKK,GAAZ,IAAkBlC,SAAUR,EAAcyC,EAAQ,QAGpD,IArD4BJ,EAqDLvC,EAAiB,GAAGU,UApDrC,KAAOJ,EAAY,IAAMiC,EAAI,KAAOjC,EAAY,GAoDA,CACpD,IAAM2C,EAAO,sBAAOR,GAAP,CAAuBD,IACpCvC,EAAoBgD,GAEpB1C,EACE1B,GACE,SAAC8B,GAAD,OACEA,EAAO,GAhOY,IAgOoB,GACvCA,EAAO,GAjOY,IAiOoB,IACtCsC,EAAQb,MACP,SAACc,GAAD,OACEA,EAAGxC,SAAS,KAAOC,EAAO,IAAMuC,EAAGxC,SAAS,KAAOC,EAAO,eAKpEV,EAAoBwC,GAGtBtC,EAAiBH,EAAiB0C,KAAI,qBAAGhC,aAErCZ,GACFC,GAA4B,MAE7B,CACDC,EACAC,EACAK,EACAC,EACAL,EACAC,EACAC,EACA8B,GACAvC,EACAG,EACAC,IAGFoB,qBAAU,WACR,IAAKzB,EAOH,OANAP,EAAkBkC,QAAU8B,aAAY,WACtC/B,OAhQI,oBAmQNhC,EAAqBiC,QAAU8B,YAAYb,GAlQ/B,oBAoQL,WACLc,aAAajE,EAAkBkC,SAC/B+B,aAAahE,EAAqBiC,YAGrC,CAACD,GAAMkB,GAAU5C,IAEpByB,qBAAU,WACRkC,SAASC,UAAY,SAACC,GACpB,IAAKzD,EAA0B,CAAC,IACtB0D,EAAQD,EAARC,IACR,GACU,YAARA,GACQ,cAARA,GACQ,cAARA,GACQ,eAARA,EAGA,OADAD,EAAEE,iBACMD,GACN,IAAK,UACe,SAAdpD,GAAsC,OAAdA,GAC1BC,EAAa,MAEf,MACF,IAAK,YACe,SAAdD,GAAsC,OAAdA,GAC1BC,EAAa,QAEf,MACF,IAAK,YACe,SAAdD,GAAsC,UAAdA,GAC1BC,EAAa,QAEf,MACF,IAAK,aACe,SAAdD,GAAsC,UAAdA,GAC1BC,EAAa,SAMrBN,GAA4B,OAG/B,CACDM,EACAD,EACAL,EACAD,IAGF,IAAM4D,GAAgBC,mBACpB,kBAAMnE,EAAYoE,MAAK,SAAC/C,EAAGgD,GAAJ,OAAUA,EAAEC,OAASjD,EAAEiD,UAAQ,IAAM,IAC5D,CAACtE,IAGGuE,GAAgBJ,mBAAQ,kBAAM3D,EAAiB+B,OAAS,IAAG,CAC/D/B,IAGIgE,GAAmBvD,uBAAY,WAC/BnB,EAASyC,OAAS,GACpBjB,MAAM,GAAD,OAAIC,oCAAJ,YAA6C,CAChDkD,OAAQ,OACRC,QAAS,CACP,eAAgB,oBAElBC,KAAMC,KAAKC,UAAU,CACnBC,KAAMhF,EACNwE,OAAQC,OAKdlE,GAAsB,KACrB,CAACkE,GAAezE,IAEnB,OACE,sBACEiF,MAAO,CACLC,QAAS,OACTC,eAAgB,SAChBC,WAAY,SACZC,cAAe,UALnB,oBAQUZ,GACR,sBACEa,UAAU,MACVL,MAAO,CACLC,QAAS,OACTE,WAAY,SACZD,eAAgB,gBAChBE,cAAe,SACfE,OAAQ,kBAPZ,UAUE,qBACEN,MAAO,CACL7C,MAAOpD,EACPqD,OAAQtD,GAHZ,SAME,wBAAQyG,IAAK7F,EAAW0C,OAAQtD,EAAeqD,MAAOpD,MAEvDoB,EACC,qBACE6E,MAAO,CACL7D,SAAU,WACVgB,MAAOpD,EACPqD,OAAQtD,EACRmG,QAAS9E,EAAa,OAAS,OAC/BqF,gBAAiB,kBACjBL,WAAY,SACZD,eAAgB,UARpB,SAWE,sBACEF,MAAO,CACLC,QAAS,OACTC,eAAgB,SAChBC,WAAY,SACZC,cAAe,SACfI,gBAAiB,QACjBC,QAAS,IAPb,UAUE,6CACA,mBACEC,QAASzE,EACT0E,KAAK,SACLC,KAAK,QACLZ,MAAO,CAAEa,OAAQ,UAAWC,MAAO,OAJrC,qBAQCzF,EACC,qCACE,mDACkBmE,GAAe,IAC9BA,GAAgBL,GAAcI,OAC3B,gBACA,MAEN,8BACE,uBAAOwB,QAAQ,WAAf,uBACA,uBACA,uBACEC,GAAG,WACHC,MAAOlG,EACPmG,SAAU,SAAClC,GAAD,OAAOhE,EAAYgE,EAAEmC,OAAOF,aAG1C,wBAAQP,QAASjB,GAAjB,qBAEA,KAEJ,kDAEE,oBAAIO,MAAO,CAAEoB,UAAW,GAAIC,SAAU,UAAtC,SACGpG,EAAYkD,KAAI,SAACmD,GAAD,OACf,+BACGA,EAAGC,KADN,KACcD,EAAG/B,SADjB,UAAY+B,EAAGC,KAAOD,EAAG/B,OAAOiC,0BAQxC,YC9aGC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,eCDdQ,EAAOC,SAEPC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFxD,SAASyD,eAAe,SAM1Bd,M","file":"static/js/main.52b99a04.chunk.js","sourcesContent":["import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport './App.css';\n\ntype Direction = 'up' | 'down' | 'left' | 'right';\n\nconst SNAKE_BODY_SQUARE_SIZE = 5;\n\nconst FPS = 1000 / 30;\nconst GAME_TICK = 1000 / 30;\nconst CANVAS_HEIGHT = 400;\nconst CANVAS_WIDTH = 400;\n\nconst SNAKESTARTING_POSITION: [number, number] = [\n  CANVAS_WIDTH / 2,\n  CANVAS_HEIGHT / 2,\n];\n\nfunction getRandomInt(max: number): number {\n  const res = Math.floor(Math.random() * Math.floor(max));\n\n  return res;\n}\n\nfunction getRandomSquareCoords(\n  checkValidity: (coords: [number, number]) => boolean\n) {\n  let newCoords: [number, number] = [\n    getRandomInt(CANVAS_WIDTH - SNAKE_BODY_SQUARE_SIZE),\n    getRandomInt(CANVAS_HEIGHT - SNAKE_BODY_SQUARE_SIZE),\n  ];\n\n  while (!checkValidity(newCoords)) {\n    newCoords = [\n      getRandomInt(CANVAS_WIDTH - SNAKE_BODY_SQUARE_SIZE),\n      getRandomInt(CANVAS_HEIGHT - SNAKE_BODY_SQUARE_SIZE),\n    ];\n  }\n\n  return newCoords;\n}\n\nfunction App() {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const renderIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const gameTicksIntervalRef = useRef<ReturnType<typeof setInterval> | null>(\n    null\n  );\n  const [userName, setUserName] = useState('');\n  const [leaderBoard, setLeaderBoard] = useState<\n    Array<{ _id: string; user: string; record: number }>\n  >([]);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [showSaveResultForm, setShowSaveResultForm] = useState(false);\n  const [isChangeDirectionBlocked, setIsChangeDirectionBlocked] = useState(\n    false\n  );\n  const [snakeSquaresData, setSnakeSquaresData] = useState<\n    Array<{ position: [number, number]; direction: Direction }>\n  >([]);\n  const [prevPositions, setPrevPositions] = useState<Array<[number, number]>>(\n    []\n  );\n  const [direction, setDirection] = useState<Direction>('left');\n  const [feedPostion, setFeedPosition] = useState<[number, number]>([0, 0]);\n\n  const startGame = useCallback(() => {\n    setSnakeSquaresData([\n      { position: SNAKESTARTING_POSITION, direction: 'left' },\n    ]);\n    setPrevPositions([]);\n    setIsGameOver(false);\n    setFeedPosition(\n      getRandomSquareCoords((coords) => {\n        return (\n          coords[0] % SNAKE_BODY_SQUARE_SIZE === 0 &&\n          (coords[0] < SNAKESTARTING_POSITION[0] ||\n            coords[0] > SNAKESTARTING_POSITION[0]) &&\n          coords[1] % SNAKE_BODY_SQUARE_SIZE === 0 &&\n          (coords[1] < SNAKESTARTING_POSITION[1] ||\n            coords[1] > SNAKESTARTING_POSITION[1])\n        );\n      })\n    );\n  }, [setSnakeSquaresData, setPrevPositions, setIsGameOver]);\n\n  const getLeaderBoard = useCallback(async () => {\n    const resp = await fetch(`${process.env.REACT_APP_SERVER!}/records`);\n\n    const data: Array<{\n      _id: string;\n      user: string;\n      record: number;\n    }> = await resp.json();\n\n    setLeaderBoard(data);\n    return data;\n  }, [setLeaderBoard]);\n\n  useEffect(() => {\n    startGame();\n    getLeaderBoard();\n  }, []);\n\n  const draw = useCallback(() => {\n    if (canvasRef.current) {\n      const canvasContext = canvasRef.current.getContext('2d')!;\n      if (!isGameOver) {\n        canvasContext.clearRect(\n          0,\n          0,\n          canvasContext.canvas.width,\n          canvasContext.canvas.height\n        );\n\n        canvasContext.fillStyle = 'black';\n        canvasContext.fillRect(\n          ...feedPostion,\n          SNAKE_BODY_SQUARE_SIZE,\n          SNAKE_BODY_SQUARE_SIZE\n        );\n\n        for (let i = 0; i < snakeSquaresData.length; i++) {\n          canvasContext.fillStyle = 'grey';\n          canvasContext.fillRect(\n            ...snakeSquaresData[i].position,\n            SNAKE_BODY_SQUARE_SIZE,\n            SNAKE_BODY_SQUARE_SIZE\n          );\n\n          canvasContext.fillStyle = 'white';\n          canvasContext.fillRect(\n            snakeSquaresData[i].position[0] + 1,\n            snakeSquaresData[i].position[1] + 1,\n            SNAKE_BODY_SQUARE_SIZE - 2,\n            SNAKE_BODY_SQUARE_SIZE - 2\n          );\n        }\n      }\n    }\n  }, [snakeSquaresData, feedPostion, isGameOver]);\n\n  const handleGameOver = useCallback(() => {\n    getLeaderBoard();\n    setShowSaveResultForm(true);\n  }, [getLeaderBoard]);\n\n  useEffect(() => {\n    if (isGameOver) {\n      handleGameOver();\n    }\n  }, [isGameOver, handleGameOver]);\n\n  const checkSnakeSelfCollision = useCallback(() => {\n    const [{ position: headPosition }, ...rest] = snakeSquaresData;\n\n    return !!rest.find(\n      (sd) =>\n        sd.position[0] === headPosition[0] && sd.position[1] === headPosition[1]\n    );\n  }, [snakeSquaresData]);\n\n  const gameTick = useCallback(() => {\n    const isSelfCollision = checkSnakeSelfCollision();\n\n    if (isSelfCollision) {\n      setIsGameOver(true);\n      return;\n    }\n\n    const checkFeedCollision = (pos: [number, number]) =>\n      pos[0] === feedPostion[0] && pos[1] === feedPostion[1];\n\n    const prevLastPosition = snakeSquaresData[snakeSquaresData.length - 1];\n\n    const newSquaresData = snakeSquaresData.map<{\n      position: [number, number];\n      direction: Direction;\n    }>(({ position: pos, ...rest }, index) => {\n      if (index === 0) {\n        switch (direction) {\n          case 'left':\n            const newLeftPos = pos[0] - SNAKE_BODY_SQUARE_SIZE;\n            return {\n              ...rest,\n              position: [\n                newLeftPos < 0\n                  ? CANVAS_WIDTH - SNAKE_BODY_SQUARE_SIZE\n                  : newLeftPos,\n                pos[1],\n              ],\n            };\n          case 'right':\n            const newRightPos = pos[0] + SNAKE_BODY_SQUARE_SIZE;\n            return {\n              ...rest,\n              position: [newRightPos >= CANVAS_WIDTH ? 0 : newRightPos, pos[1]],\n            };\n          case 'up':\n            const newUpPos = pos[1] - SNAKE_BODY_SQUARE_SIZE;\n            return {\n              ...rest,\n              position: [\n                pos[0],\n                newUpPos < 0\n                  ? CANVAS_HEIGHT - SNAKE_BODY_SQUARE_SIZE\n                  : newUpPos,\n              ],\n            };\n          case 'down':\n            const newDownPos = pos[1] + SNAKE_BODY_SQUARE_SIZE;\n            return {\n              ...rest,\n              position: [pos[0], newDownPos >= CANVAS_HEIGHT ? 0 : newDownPos],\n            };\n          default:\n            return { ...rest, position: pos };\n        }\n      }\n\n      return { ...rest, position: prevPositions[index - 1] };\n    });\n\n    if (checkFeedCollision(snakeSquaresData[0].position)) {\n      const newData = [...newSquaresData, prevLastPosition];\n      setSnakeSquaresData(newData);\n\n      setFeedPosition(\n        getRandomSquareCoords(\n          (coords) =>\n            coords[0] % SNAKE_BODY_SQUARE_SIZE === 0 &&\n            coords[1] % SNAKE_BODY_SQUARE_SIZE === 0 &&\n            !newData.find(\n              (np) =>\n                np.position[0] === coords[0] && np.position[1] === coords[1]\n            )\n        )\n      );\n    } else {\n      setSnakeSquaresData(newSquaresData);\n    }\n\n    setPrevPositions(snakeSquaresData.map(({ position }) => position));\n\n    if (isChangeDirectionBlocked) {\n      setIsChangeDirectionBlocked(false);\n    }\n  }, [\n    snakeSquaresData,\n    setSnakeSquaresData,\n    feedPostion,\n    setFeedPosition,\n    prevPositions,\n    setPrevPositions,\n    direction,\n    checkSnakeSelfCollision,\n    setIsGameOver,\n    isChangeDirectionBlocked,\n    setIsChangeDirectionBlocked,\n  ]);\n\n  useEffect(() => {\n    if (!isGameOver) {\n      renderIntervalRef.current = setInterval(() => {\n        draw();\n      }, FPS);\n\n      gameTicksIntervalRef.current = setInterval(gameTick, GAME_TICK);\n\n      return () => {\n        clearTimeout(renderIntervalRef.current!);\n        clearTimeout(gameTicksIntervalRef.current!);\n      };\n    }\n  }, [draw, gameTick, isGameOver]);\n\n  useEffect(() => {\n    document.onkeydown = (e) => {\n      if (!isChangeDirectionBlocked) {\n        const { key } = e;\n        if (\n          key === 'ArrowUp' ||\n          key === 'ArrowDown' ||\n          key === 'ArrowLeft' ||\n          key === 'ArrowRight'\n        ) {\n          e.preventDefault();\n          switch (key) {\n            case 'ArrowUp':\n              if (direction !== 'down' && direction !== 'up') {\n                setDirection('up');\n              }\n              break;\n            case 'ArrowDown':\n              if (direction !== 'down' && direction !== 'up') {\n                setDirection('down');\n              }\n              break;\n            case 'ArrowLeft':\n              if (direction !== 'left' && direction !== 'right') {\n                setDirection('left');\n              }\n              break;\n            case 'ArrowRight':\n              if (direction !== 'left' && direction !== 'right') {\n                setDirection('right');\n              }\n              break;\n          }\n        }\n\n        setIsChangeDirectionBlocked(true);\n      }\n    };\n  }, [\n    setDirection,\n    direction,\n    setIsChangeDirectionBlocked,\n    isChangeDirectionBlocked,\n  ]);\n\n  const currentRecord = useMemo(\n    () => leaderBoard.sort((a, b) => b.record - a.record)[0] || 0,\n    [leaderBoard]\n  );\n\n  const currentResult = useMemo(() => snakeSquaresData.length - 1, [\n    snakeSquaresData,\n  ]);\n\n  const handleSaveResult = useCallback(() => {\n    if (userName.length > 3) {\n      fetch(`${process.env.REACT_APP_SERVER!}/records`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          name: userName,\n          record: currentResult,\n        }),\n      });\n    }\n\n    setShowSaveResultForm(false);\n  }, [currentResult, userName]);\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        flexDirection: 'column',\n      }}\n    >\n      Score: {currentResult}\n      <div\n        className=\"App\"\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          flexDirection: 'column',\n          border: '1px solid grey',\n        }}\n      >\n        <div\n          style={{\n            width: CANVAS_WIDTH,\n            height: CANVAS_HEIGHT,\n          }}\n        >\n          <canvas ref={canvasRef} height={CANVAS_HEIGHT} width={CANVAS_WIDTH} />\n        </div>\n        {isGameOver ? (\n          <div\n            style={{\n              position: 'absolute',\n              width: CANVAS_WIDTH,\n              height: CANVAS_HEIGHT,\n              display: isGameOver ? 'flex' : 'none',\n              backgroundColor: 'rgba(0,0,0,0.4)',\n              alignItems: 'center',\n              justifyContent: 'center',\n            }}\n          >\n            <div\n              style={{\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                flexDirection: 'column',\n                backgroundColor: 'white',\n                padding: 15,\n              }}\n            >\n              <span>GAME OVER</span>\n              <a\n                onClick={startGame}\n                role=\"button\"\n                href=\"#noop\"\n                style={{ cursor: 'pointer', color: 'red' }}\n              >\n                Restart\n              </a>\n              {showSaveResultForm ? (\n                <>\n                  <span>\n                    Your Result is {currentResult}{' '}\n                    {currentResult > currentRecord.record\n                      ? '(NEW RECORD!)'\n                      : ''}\n                  </span>\n                  <p>\n                    <label htmlFor=\"username\">Your Name</label>\n                    <br />\n                    <input\n                      id=\"username\"\n                      value={userName}\n                      onChange={(e) => setUserName(e.target.value)}\n                    />\n                  </p>\n                  <button onClick={handleSaveResult}>Save</button>\n                </>\n              ) : null}\n\n              <div>\n                Leader's Board:\n                <ul style={{ maxHeight: 75, overflow: 'scroll' }}>\n                  {leaderBoard.map((lb) => (\n                    <li key={`${lb.user + lb.record.toString()}`}>\n                      {lb.user}: {lb.record}\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            </div>\n          </div>\n        ) : null}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}